name: "üåê Generate Release Page"
description: "Generate GitHub Pages for each release"

inputs:
  app-directory:
    description: "Directory containing the private repository"
    required: false
    default: "app"
  version:
    description: "Version string for the release"
    required: true
  commit-count:
    description: "Number of commits to show per branch"
    required: false
    default: "10"
  branches:
    description: "Comma-separated list of branches to include"
    required: false
    default: "dev,main"
  changelog:
    description: "Generated changelog content"
    required: true

outputs:
  page-url:
    description: "URL of the generated release page"
    value: ${{ steps.generate-page.outputs.page-url }}

runs:
  using: composite
  steps:
    - name: üåê Generate release page
      id: generate-page
      shell: bash
      run: |
        echo "Generating release page..."

        # ËøõÂÖ•ÁßÅÊúâ‰ªìÂ∫ìÁõÆÂΩïËé∑Âèñ‰ø°ÊÅØ
        cd ${{ inputs.app-directory }}/

        # Ëé∑ÂèñÂΩìÂâçÁßÅÊúâ‰ªìÂ∫ìÁöÑ‰ø°ÊÅØ
        CURRENT_COMMIT=$(git rev-parse HEAD)
        CURRENT_COMMIT_SHORT=$(git rev-parse --short HEAD)
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

        # Ëé∑ÂèñËøúÁ®ã‰ªìÂ∫ì‰ø°ÊÅØ
        REMOTE_URL=$(git remote get-url origin)
        if [[ $REMOTE_URL == *"github.com"* ]]; then
          REPO_PATH=$(echo $REMOTE_URL | sed 's|.*github.com[/:]\([^/]*\/[^/]*\).*|\1|' | sed 's|\.git$||')
          GITHUB_BASE_URL="https://github.com/${REPO_PATH}"
        else
          REPO_PATH=""
          GITHUB_BASE_URL=""
        fi

        # ËøîÂõûÊ†πÁõÆÂΩï
        cd ..

        # Ëé∑ÂèñËß¶Âèë‰ø°ÊÅØ
        TRIGGER_EVENT="${{ github.event_name }}"
        TRIGGER_REPO="${{ github.repository }}"
        TRIGGER_BRANCH="${{ github.ref_name }}"
        TRIGGER_COMMIT="${{ github.sha }}"
        TRIGGER_AUTHOR="${{ github.actor }}"

        # Ëé∑ÂèñÊèê‰∫§Ê∂àÊÅØÔºàËΩ¨‰πâÁâπÊÆäÂ≠óÁ¨¶Ôºâ
        COMMIT_MESSAGE=""
        if [[ "${{ github.event_name }}" == "push" ]]; then
          COMMIT_MESSAGE="${{ github.event.head_commit.message }}"
        elif [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
          COMMIT_MESSAGE="${{ github.event.client_payload.commit_message }}"
        fi
        # ËΩ¨‰πâÁâπÊÆäÂ≠óÁ¨¶‰ª•ÈÅøÂÖç sed ÈîôËØØ
        COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | sed 's/[\/&]/\\&/g' | tr '\n' ' ' | tr '\r' ' ')

        # ÂàõÂª∫ÂèëÂ∏ÉÁõÆÂΩï - ‰ΩøÁî®releaseÁöÑÂîØ‰∏ÄhashÁ°Æ‰øùÊØèÊ¨°ÊûÑÂª∫ÁöÑÂîØ‰∏ÄÊÄß
        # ‰ΩøÁî®Ëß¶Âèë‰ªìÂ∫ìÁöÑcommit hash‰Ωú‰∏∫È°µÈù¢Ë∑ØÂæÑÔºåËøôÊ†∑ÂèØ‰ª•ÈÄöËøáAPIÂáÜÁ°ÆËé∑ÂèñÂØπÂ∫îÁöÑreleaseÊï∞ÊçÆ
        RELEASE_HASH="${{ github.sha }}"
        RELEASE_HASH_SHORT="${RELEASE_HASH:0:7}"
        RELEASE_DIR="pages/${RELEASE_HASH}"
        mkdir -p "$RELEASE_DIR"

        echo "Creating release page in: $RELEASE_DIR"
        echo "Version: ${{ inputs.version }}"
        echo "Release Hash: $RELEASE_HASH"
        echo "Release Hash (short): $RELEASE_HASH_SHORT"
        echo "Private Commit: $CURRENT_COMMIT"

        # Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥
        CREATED_AT=$(date -u +'%Y-%m-%dT%H:%M:%S.%3NZ')

        # ÊûÑÂª∫‰∫ßÁâ©Â∞ÜÈÄöËøáÂâçÁ´ØJavaScriptÂä®ÊÄÅËé∑ÂèñÔºåÁÆÄÂåñÂêéÁ´ØÈÄªËæë
        DOWNLOAD_FILES="[]"
        
        echo "üìù Release assets will be fetched dynamically by frontend JavaScript"
        echo "ÔøΩ GitHub API endpoints:"
        echo "  - Repository: ${{ github.repository }}"
        echo "  - Version: ${{ inputs.version }}"
        echo "  - Release Hash: $RELEASE_HASH"
        echo "  - API Base: https://api.github.com/repos/${{ github.repository }}"
          
          for VERSION_TAG in "${VERSION_VARIANTS[@]}"; do
            echo "  üè∑Ô∏è Trying version tag: $VERSION_TAG"
            
            RELEASE_INFO=$(curl -s \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION_TAG")
            
            # Ê£ÄÊü•APIÂìçÂ∫î
            if echo "$RELEASE_INFO" | jq -e '.tag_name' >/dev/null 2>&1; then
              ASSETS_COUNT=$(echo "$RELEASE_INFO" | jq '.assets | length')
              echo "  ‚úÖ Found release: $VERSION_TAG with $ASSETS_COUNT assets"
              
              if [[ "$ASSETS_COUNT" -gt 0 ]]; then
                DOWNLOAD_FILES=$(echo "$RELEASE_INFO" | jq -c '.assets | map({
                  name: .name,
                  size: .size,
                  browser_download_url: .browser_download_url,
                  download_count: .download_count,
                  content_type: .content_type,
                  updated_at: .updated_at
                })')
                echo "  üìä Successfully extracted $ASSETS_COUNT assets"
                break
              else
                echo "  ‚ö†Ô∏è Release found but no assets available"
              fi
            else
              echo "  ‚ùå No release found for tag: $VERSION_TAG"
              # ÊâìÂç∞ÈîôËØØ‰ø°ÊÅØÁî®‰∫éË∞ÉËØï
              ERROR_MSG=$(echo "$RELEASE_INFO" | jq -r '.message // "Unknown error"')
              echo "  üîç API Error: $ERROR_MSG"
            fi
          done
          
          # ÊñπÊ≥ï2: Â¶ÇÊûúÈÄöËøáÁâàÊú¨Âè∑Ê≤°ÊâæÂà∞ÔºåÊêúÁ¥¢ÊâÄÊúâreleasesÊâæÂà∞ÂåπÈÖçÁöÑcommit
          if [[ "$DOWNLOAD_FILES" == "[]" ]]; then
            echo "ÔøΩ Method 2: Searching by target commit"
            echo "  üéØ Looking for releases targeting commit: $RELEASE_HASH"
            
            ALL_RELEASES=$(curl -s \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100")
            
            if echo "$ALL_RELEASES" | jq -e '.[0]' >/dev/null 2>&1; then
              TOTAL_RELEASES=$(echo "$ALL_RELEASES" | jq 'length')
              echo "  üìã Found $TOTAL_RELEASES total releases, searching..."
              
              # Êü•Êâætarget_commitishÂåπÈÖçÁöÑrelease
              MATCHING_RELEASE=$(echo "$ALL_RELEASES" | jq --arg hash "$RELEASE_HASH" --arg short_hash "$RELEASE_HASH_SHORT" '
                .[] | select(
                  .target_commitish == $hash or 
                  .target_commitish == $short_hash or
                  (.target_commitish | startswith($short_hash))
                ) | select(.assets | length > 0)')
              
              if [[ -n "$MATCHING_RELEASE" ]] && [[ "$MATCHING_RELEASE" != "null" ]]; then
                FOUND_TAG=$(echo "$MATCHING_RELEASE" | jq -r '.tag_name')
                ASSETS_COUNT=$(echo "$MATCHING_RELEASE" | jq '.assets | length')
                echo "  üéØ Found matching release: $FOUND_TAG with $ASSETS_COUNT assets"
                
                DOWNLOAD_FILES=$(echo "$MATCHING_RELEASE" | jq -c '.assets | map({
                  name: .name,
                  size: .size,
                  browser_download_url: .browser_download_url,
                  download_count: .download_count,
                  content_type: .content_type,
                  updated_at: .updated_at
                })')
              else
                echo "  ‚ùå No release found with matching commit hash"
              fi
            else
              echo "  ‚ùå Failed to fetch releases list"
              ERROR_MSG=$(echo "$ALL_RELEASES" | jq -r '.message // "Unknown error"')
              echo "  üîç API Error: $ERROR_MSG"
            fi
          fi
          
          # ÊñπÊ≥ï3: Â¶ÇÊûúËøòÊòØÊ≤°ÊâæÂà∞ÔºåÂ∞ùËØïÊúÄÊñ∞ÁöÑrelease‰Ωú‰∏∫fallback
          if [[ "$DOWNLOAD_FILES" == "[]" ]]; then
            echo "üì¶ Method 3: Using latest release as fallback"
            
            LATEST_RELEASE=$(curl -s \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            
            if echo "$LATEST_RELEASE" | jq -e '.tag_name' >/dev/null 2>&1; then
              LATEST_TAG=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')
              ASSETS_COUNT=$(echo "$LATEST_RELEASE" | jq '.assets | length')
              echo "  üì¶ Using latest release: $LATEST_TAG with $ASSETS_COUNT assets"
              
              if [[ "$ASSETS_COUNT" -gt 0 ]]; then
                DOWNLOAD_FILES=$(echo "$LATEST_RELEASE" | jq -c '.assets | map({
                  name: .name,
                  size: .size,
                  browser_download_url: .browser_download_url,
                  download_count: .download_count,
                  content_type: .content_type,
                  updated_at: .updated_at
                })')
              fi
            else
              echo "  ‚ùå No latest release available"
            fi
          fi
          
          # ÊúÄÁªàÁªìÊûú
          FINAL_COUNT=$(echo "$DOWNLOAD_FILES" | jq 'length')
          if [[ "$FINAL_COUNT" -gt 0 ]]; then
            echo "‚úÖ Successfully found $FINAL_COUNT download files"
            echo "üìã Assets found:"
            echo "$DOWNLOAD_FILES" | jq -r '.[] | "  - \(.name) (\(.size | . / 1024 / 1024 * 100 | floor / 100)MB)"'
          else
            echo "‚ö†Ô∏è No assets found for this release"
          fi
        else
          echo "‚ùå GITHUB_TOKEN not available, cannot fetch release assets"
        fi

        # Â§çÂà∂Âπ∂Â§ÑÁêÜÊ®°ÊùøÊñá‰ª∂
        cp pages/release-template.html "$RELEASE_DIR/index.html"

        # ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáè‰æõ Python ËÑöÊú¨‰ΩøÁî®
        export REPLACE_VERSION="${{ inputs.version }}"
        export REPLACE_CREATED_AT="$CREATED_AT"
        export REPLACE_COMMIT_HASH="$CURRENT_COMMIT"
        export REPLACE_PRIVATE_BRANCH="$CURRENT_BRANCH"
        export REPLACE_TRIGGER_EVENT="$TRIGGER_EVENT"
        export REPLACE_TRIGGER_REPO="$TRIGGER_REPO"
        export REPLACE_TRIGGER_BRANCH="$TRIGGER_BRANCH"
        export REPLACE_TRIGGER_COMMIT="$TRIGGER_COMMIT"
        export REPLACE_TRIGGER_AUTHOR="$TRIGGER_AUTHOR"
        export REPLACE_COMMIT_MESSAGE="$COMMIT_MESSAGE"
        export REPLACE_GITHUB_BASE_URL="$GITHUB_BASE_URL"
        export REPLACE_REPO_PATH="$REPO_PATH"
        export REPLACE_DOWNLOAD_FILES="$DOWNLOAD_FILES"

        # Â∞Ü changelog ÂÜôÂÖ•‰∏¥Êó∂Êñá‰ª∂‰ª•ÈÅøÂÖçÂ§öË°åÂÜÖÂÆπÁöÑÈóÆÈ¢ò
        CHANGELOG_FILE=$(mktemp)
        printf '%s' '${{ inputs.changelog }}' > "$CHANGELOG_FILE"
        export REPLACE_CHANGELOG_FILE="$CHANGELOG_FILE"

        # ‰ΩøÁî®Â§ñÈÉ® Python ËÑöÊú¨Â§ÑÁêÜÊ®°ÊùøÊõøÊç¢
        python3 ./.github/actions/generate-release-page/process_template.py "$RELEASE_DIR"

        # Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
        rm -f "$CHANGELOG_FILE"

        # Êõ¥Êñ∞ releases.json
        echo "Updating releases.json..."
        if [[ ! -f "pages/releases.json" ]]; then
          echo '{"releases":[]}' > pages/releases.json
        fi

        # ÂÆâË£Ö jq Â¶ÇÊûú‰∏çÂ≠òÂú®
        if ! command -v jq >/dev/null 2>&1; then
          echo "Installing jq..."
          sudo apt-get update && sudo apt-get install -y jq
        fi

        # ÂàõÂª∫Êñ∞ÁöÑÂèëÂ∏ÉËÆ∞ÂΩï
        NEW_RELEASE=$(jq -n \
          --arg version "${{ inputs.version }}" \
          --arg commit_hash "$CURRENT_COMMIT" \
          --arg created_at "$CREATED_AT" \
          --arg branch "$CURRENT_BRANCH" \
          --arg trigger_event "$TRIGGER_EVENT" \
          --arg trigger_repo "$TRIGGER_REPO" \
          --arg trigger_branch "$TRIGGER_BRANCH" \
          --arg trigger_commit "$TRIGGER_COMMIT" \
          --arg trigger_author "$TRIGGER_AUTHOR" \
          --arg commit_message "$COMMIT_MESSAGE" \
          --arg github_base_url "$GITHUB_BASE_URL" \
          --arg repo_path "$REPO_PATH" \
          --arg status "success" \
          '{
            version: $version,
            commit_hash: $commit_hash,
            created_at: $created_at,
            branch: $branch,
            private_branch: $branch,
            trigger_event: $trigger_event,
            trigger_repo: $trigger_repo,
            trigger_branch: $trigger_branch,
            trigger_commit: $trigger_commit,
            trigger_author: $trigger_author,
            commit_message: $commit_message,
            status: $status,
            github_base_url: $github_base_url,
            repo_path: $repo_path
          }')

        # Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®Áõ∏ÂêåÁâàÊú¨ÁöÑËÆ∞ÂΩï
        EXISTING=$(jq --arg version "${{ inputs.version }}" '.releases[] | select(.version == $version)' pages/releases.json)
        if [[ -z "$EXISTING" ]]; then
          # Ê∑ªÂä†Âà∞ releases.jsonÔºà‰øùÁïôÊúÄËøë50‰∏™Ôºâ
          jq --argjson new_release "$NEW_RELEASE" '.releases |= [($new_release)] + .[0:49]' pages/releases.json > pages/releases.json.tmp
          mv pages/releases.json.tmp pages/releases.json
          echo "Added new release: ${{ inputs.version }}"
        else
          echo "Release for version ${{ inputs.version }} already exists, updating existing record"
          # Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩï
          jq --argjson new_release "$NEW_RELEASE" '.releases = [($new_release)] + (.releases | map(select(.version != ($new_release.version))))' pages/releases.json > pages/releases.json.tmp
          mv pages/releases.json.tmp pages/releases.json
        fi

        # ËæìÂá∫È°µÈù¢ URL - ‰ΩøÁî®release hash‰Ωú‰∏∫Ë∑ØÂæÑ
        REPO_NAME=$(basename "${{ github.repository }}")
        if [[ -n "${{ github.repository }}" ]]; then
          PAGE_URL="https://${{ github.repository_owner }}.github.io/${REPO_NAME}/${RELEASE_HASH}/"
        else
          PAGE_URL="/${RELEASE_HASH}/"
        fi

        echo "page-url=$PAGE_URL" >> $GITHUB_OUTPUT
        echo "Generated release page: $PAGE_URL"
        echo "Files created:"
        ls -la "$RELEASE_DIR/"
        echo "Updated releases.json"
